---
phase: 02-prompt-generation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - lib/prompt.sh
  - lib/commands/generate.sh
  - bin/gsd-ralph
  - tests/prompt.bats
  - tests/generate.bats
autonomous: true

must_haves:
  truths:
    - "extract_tasks_to_fix_plan extracts task names from GSD XML plan format into a checklist with - [ ] items"
    - "extract_tasks_to_fix_plan handles plans with no tasks gracefully (empty output, no error)"
    - "generate_prompt_md renders the base PROMPT.md template and appends scope lock, merge order, and peer visibility sections"
    - "Generated PROMPT.md for a single-plan phase omits peer visibility paths and notes it is the only plan"
    - "Generated PROMPT.md for a multi-plan phase lists peer worktree status file paths"
    - "User can run gsd-ralph generate N and get PROMPT.md, fix_plan.md, AGENT.md, and .ralphrc generated into an output directory per plan"
    - "Generated .ralphrc contains the project's detected test and build commands"
    - "Generate command validates phase exists and plans are found before generating"
  artifacts:
    - path: "lib/prompt.sh"
      provides: "File generation pipeline for PROMPT.md, fix_plan.md, and dynamic sections"
      contains: "extract_tasks_to_fix_plan"
      min_lines: 100
    - path: "lib/commands/generate.sh"
      provides: "Generate subcommand orchestrating discovery and generation"
      contains: "cmd_generate"
      min_lines: 60
    - path: "tests/prompt.bats"
      provides: "Unit tests for prompt generation functions"
      min_lines: 80
    - path: "tests/generate.bats"
      provides: "Integration tests for generate command"
      min_lines: 80
  key_links:
    - from: "lib/commands/generate.sh"
      to: "lib/discovery.sh"
      via: "find_phase_dir and discover_plan_files calls"
      pattern: "find_phase_dir\\|discover_plan_files"
    - from: "lib/commands/generate.sh"
      to: "lib/prompt.sh"
      via: "extract_tasks_to_fix_plan and generate_prompt_md calls"
      pattern: "extract_tasks_to_fix_plan\\|generate_prompt_md"
    - from: "lib/commands/generate.sh"
      to: "lib/templates.sh"
      via: "render_template for .ralphrc and AGENT.md"
      pattern: "render_template"
    - from: "lib/prompt.sh"
      to: "templates/PROMPT.md.template"
      via: "render_template call for base PROMPT.md"
      pattern: "PROMPT\\.md\\.template"
    - from: "bin/gsd-ralph"
      to: "lib/commands/generate.sh"
      via: "subcommand dispatch"
      pattern: "source.*generate\\.sh"
---

<objective>
Build the file generation pipeline and `generate` subcommand that produces per-plan output files from GSD plans. By the end, a user can run `gsd-ralph generate N` and get PROMPT.md, fix_plan.md, AGENT.md, and .ralphrc generated for each plan in phase N.

Purpose: Deliver requirements EXEC-02 (PROMPT.md generation), EXEC-03 (fix_plan.md task extraction), and EXEC-04 (.ralphrc generation). The generate command also serves as a debugging/testing tool for Phase 3's execute command, which will call the same generation functions internally after creating worktrees.
Output: Working generate command, prompt generation library, comprehensive tests.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-prompt-generation/02-RESEARCH.md
@.planning/phases/02-prompt-generation/02-01-SUMMARY.md
@lib/common.sh
@lib/config.sh
@lib/templates.sh
@lib/discovery.sh
@templates/PROMPT.md.template
@templates/AGENT.md.template
@templates/ralphrc.template
@scripts/ralph-worktrees.sh
@tests/test_helper/common.bash
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/prompt.sh with file generation functions and unit tests</name>
  <files>lib/prompt.sh, tests/prompt.bats</files>
  <action>
Create `lib/prompt.sh` implementing the file generation pipeline for PROMPT.md and fix_plan.md. Follow patterns from `lib/common.sh` and reference implementation in `scripts/ralph-worktrees.sh`.

**Functions to implement:**

1. **extract_tasks_to_fix_plan(plan_file, output_file)** -- Extract task names from GSD XML into a fix_plan.md checklist.
   - Validate `plan_file` exists, return 1 if not (with print_error)
   - Use `python3 -c` with `re.findall` using the regex pattern from the research doc (Pattern 3: XML Task Extraction via Python 3) to find all task blocks with re.DOTALL for multiline matching
   - For each task block, extract the name element content and write `- [ ] {name}` to output_file
   - Handle plans with no task blocks gracefully (empty file, no error, return 0)
   - Report task count via `print_verbose`
   - Redirect python3 stderr to /dev/null to suppress any parsing noise

2. **generate_prompt_md(output_path, template_path, phase_num, plan_id, plan_count, plan_filename, phase_dir, project_name, project_lang, test_cmd, build_cmd, repo_name, parent_dir)** -- Generate complete PROMPT.md for a plan.
   - Step 1: Call `render_template "$template_path" "$output_path"` with PROJECT_NAME, PROJECT_LANG, TEST_CMD, BUILD_CMD key-value pairs
   - Step 2: Call `append_scope_lock` to add scope lock section
   - Step 3: Call `append_merge_order` to add merge order section
   - Step 4: Call `append_peer_visibility` to add peer visibility section
   - All variables must be `local` except the output file

3. **append_scope_lock(output_path, phase_num, plan_id, plan_filename, phase_dir)** -- Append scope lock section.
   - Use `cat >> "$output_path" << EOF` with the scope lock content
   - Include phase number, plan ID, plan filename, and phase directory in the section
   - Format: heading "## Scope Lock", bold statement of which phase/plan, bullet list of constraints

4. **append_merge_order(output_path, plan_id, plan_count)** -- Append merge order section.
   - If `plan_count` <= 1: skip entirely (single-plan phases don't need merge order)
   - Otherwise: append "## Merge Order" section noting this plan's position (Plan NN of total)
   - Include instruction that branches merge in plan order

5. **append_peer_visibility(output_path, phase_num, plan_id, plan_count, repo_name, parent_dir)** -- Append peer visibility section.
   - If `plan_count` <= 1: append note "_No peer worktrees -- this is the only plan in this phase._"
   - Otherwise: append "## Read-Only Peer Visibility" with instructions about reading peer files
   - List status file paths for each peer: `${parent_dir}/${repo_name}-p${phase_num}-${peer_id}/.ralph/status.json`
   - Also list source access: `${parent_dir}/${repo_name}-p${phase_num}-${peer_id}/` (full read access, not just status)
   - Skip the current plan's own ID when listing peers
   - Use `seq 1 "$plan_count"` and `printf "%02d"` for peer IDs

**Header:** `#!/bin/bash` and `# lib/prompt.sh -- PROMPT.md and fix_plan.md generation pipeline`

**Unit tests (tests/prompt.bats):** Write tests covering:

1. "extract_tasks_to_fix_plan extracts tasks from multi-plan fixture" -- Use multi-plan fixture (02-01-PLAN.md has 2 tasks), run extract, assert output has 2 lines with `- [ ]`
2. "extract_tasks_to_fix_plan extracts task names correctly" -- Verify extracted names match fixture task names
3. "extract_tasks_to_fix_plan handles empty plan" -- Use edge-case fixture with no tasks, assert output file is empty, assert return 0
4. "extract_tasks_to_fix_plan returns 1 for missing file" -- Call with nonexistent file, assert return 1
5. "extract_tasks_to_fix_plan handles single plan fixture" -- Use single-plan fixture, assert 1 task extracted
6. "append_scope_lock adds scope section" -- Create temp file, call append_scope_lock, assert file contains "Scope Lock" and plan/phase identifiers
7. "append_merge_order adds section for multi-plan" -- Call with plan_count=3, assert file contains "Merge Order"
8. "append_merge_order skips for single plan" -- Call with plan_count=1, assert file does NOT contain "Merge Order"
9. "append_peer_visibility lists peer paths for multi-plan" -- Call with plan_count=3, plan_id=01, assert output contains paths for plan 02 and 03 but not 01
10. "append_peer_visibility notes no peers for single plan" -- Call with plan_count=1, assert output contains "only plan"
11. "generate_prompt_md creates complete file" -- Call with all args and a temp template, assert output file exists and contains scope lock, project name
12. "generate_prompt_md uses template variables" -- Create a simple template with {{PROJECT_NAME}}, render it, verify substitution worked

**Test setup:** Source lib/common.sh, lib/templates.sh, lib/prompt.sh in setup(). Use PROJECT_ROOT from _common_setup. Copy fixture files from `$PROJECT_ROOT/tests/test_helper/fixtures/` as needed.
  </action>
  <verify>
Run `shellcheck -s bash lib/prompt.sh` -- no errors.
Run `make test` -- all tests pass including prompt.bats.
Run `grep -c '@test' tests/prompt.bats` -- at least 10 test cases.
Manually test: `source lib/common.sh && source lib/templates.sh && source lib/prompt.sh && extract_tasks_to_fix_plan .planning/phases/01-project-initialization/01-02-PLAN.md /tmp/test_fix_plan.md && cat /tmp/test_fix_plan.md` -- should show 2 task items from the real Phase 1 plan.
  </verify>
  <done>
lib/prompt.sh has 5 functions (extract_tasks_to_fix_plan, generate_prompt_md, append_scope_lock, append_merge_order, append_peer_visibility) implementing the file generation pipeline. 10+ unit tests pass in prompt.bats. Task extraction uses python3 regex for reliable multiline XML parsing. Dynamic sections handle single-plan vs multi-plan correctly. ShellCheck clean.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create generate subcommand with integration tests</name>
  <files>lib/commands/generate.sh, bin/gsd-ralph, tests/generate.bats</files>
  <action>
Create `lib/commands/generate.sh` implementing the `gsd-ralph generate N` subcommand. This command orchestrates discovery + generation to produce per-plan output files. Also update `bin/gsd-ralph` to source the new libraries needed and add generate to the usage text.

**cmd_generate() function flow:**

1. **Parse args:** Require phase number as first positional argument. Support `-h/--help` for generate_usage. Support `--output-dir DIR` to specify where generated files go (default: `.ralph/generated`). Support `-v/--verbose` for verbose output.
2. **Validate environment:** Must be inside a git repo (`git rev-parse --is-inside-work-tree`). Must have `.planning/` directory. Must have been initialized (`[[ -d ".ralph" ]]` or die with "Run gsd-ralph init first").
3. **Source required libraries:** Source `lib/discovery.sh`, `lib/prompt.sh`, `lib/templates.sh` (if not already sourced via entry point).
4. **Find phase directory:** Call `find_phase_dir "$phase_num"`. Die with actionable error if not found ("Phase N not found. Check .planning/phases/ for available phases.").
5. **Discover plan files:** Call `discover_plan_files "$PHASE_DIR"`. Die if no plans found.
6. **Detect project type:** Call `detect_project_type "."` to get DETECTED_LANG, DETECTED_TEST_CMD, DETECTED_BUILD_CMD.
7. **Derive project context:** `project_name=$(basename "$(git rev-parse --show-toplevel)")`, `repo_name=$project_name`, `parent_dir=$(dirname "$(git rev-parse --show-toplevel)")`.
8. **Generate files for each plan:** Loop over PLAN_FILES:
   a. Extract plan_id via `plan_id_from_filename`
   b. Create output directory: `${output_dir}/plan-${plan_id}/`
   c. `mkdir -p` the output dir and `${output_dir}/plan-${plan_id}/logs`
   d. Call `extract_tasks_to_fix_plan "$plan_file" "${plan_output_dir}/fix_plan.md"`
   e. Call `generate_prompt_md` with all required args, template path `$GSD_RALPH_HOME/templates/PROMPT.md.template`, output to `${plan_output_dir}/PROMPT.md`
   f. Call `render_template "$GSD_RALPH_HOME/templates/AGENT.md.template" "${plan_output_dir}/AGENT.md"` with PROJECT_NAME, PROJECT_LANG, TEST_CMD, BUILD_CMD
   g. Call `render_template "$GSD_RALPH_HOME/templates/ralphrc.template" "${plan_output_dir}/.ralphrc"` with PROJECT_NAME, PROJECT_TYPE (=DETECTED_LANG), TEST_CMD, BUILD_CMD
   h. Create initial `status.json` using `cat > "${plan_output_dir}/status.json"` with phase, plan, status:ready, started_at:null, last_activity from `iso_timestamp`
   i. Print progress: `print_success "Generated files for Plan ${phase_num}-${plan_id}"`
9. **Print summary:** Header with "Generation complete", count of plans processed, output directory location, list of files generated per plan.

**generate_usage() function:** Print help text explaining the command, usage, and options.

**Update bin/gsd-ralph:**
- Add `source "$GSD_RALPH_HOME/lib/templates.sh"` to the library sourcing section (it is currently not sourced in the entry point, only used by init.sh directly). Actually, check if it is already sourced -- if not, add it. The entry point currently only sources common.sh and config.sh.
- Add `generate` to the usage text's Commands list: `  generate N  Generate per-plan files for phase N (for testing/debugging)`
- The subcommand dispatch (`source "$GSD_RALPH_HOME/lib/commands/${COMMAND}.sh"`) will automatically load generate.sh when the command is "generate".

**Source additional libraries in generate.sh:** Since the entry point may not source all libraries, the generate command should source them:
```bash
source "$GSD_RALPH_HOME/lib/templates.sh"
source "$GSD_RALPH_HOME/lib/discovery.sh"
source "$GSD_RALPH_HOME/lib/prompt.sh"
```

Place these at the top of generate.sh (before cmd_generate function) so they are available when the command runs.

**Integration tests (tests/generate.bats):**

Each test creates a realistic environment: git repo, .planning/ structure with plan files, .ralph/ directory (simulating init has been run), then runs `gsd-ralph generate`.

Test setup:
- `_common_setup`, `create_test_repo`, `create_gsd_structure`
- `mkdir -p .ralph/logs` (simulate init)
- Copy fixture plan files into `.planning/phases/02-test-phase/` (or create them inline)

Required test cases:

1. "generate creates output directory" -- Run generate, assert `.ralph/generated/` exists
2. "generate creates per-plan directories" -- With 2-plan fixture, assert `plan-01/` and `plan-02/` dirs exist
3. "generate creates PROMPT.md per plan" -- Assert `plan-01/PROMPT.md` exists and is non-empty
4. "generate creates fix_plan.md per plan" -- Assert `plan-01/fix_plan.md` exists with task checkboxes
5. "generate creates AGENT.md per plan" -- Assert `plan-01/AGENT.md` exists
6. "generate creates .ralphrc per plan" -- Assert `plan-01/.ralphrc` exists
7. "generate creates status.json per plan" -- Assert `plan-01/status.json` exists with valid JSON (use jq to verify)
8. "generate PROMPT.md contains project name" -- Assert PROMPT.md contains the repo name
9. "generate PROMPT.md contains scope lock" -- Assert PROMPT.md contains "Scope Lock"
10. "generate PROMPT.md contains peer visibility" -- With multi-plan, assert PROMPT.md contains peer paths
11. "generate fix_plan.md has correct task count" -- With fixture that has 2 tasks, assert fix_plan.md has 2 lines
12. "generate fails without phase argument" -- Run with no args, assert_failure
13. "generate fails for nonexistent phase" -- Run with phase 99, assert_failure, assert output contains error
14. "generate fails without init" -- Remove .ralph/, run generate, assert_failure, assert output mentions init
15. "generate handles single-plan phase" -- With single PLAN.md, assert no peer paths in PROMPT.md, assert "only plan" note
16. "generate .ralphrc has no unresolved placeholders" -- Assert grep for `{{` in .ralphrc finds nothing
17. "generate supports --output-dir flag" -- Run with custom output dir, assert files appear there

**Creating fixture plan files in tests:** Rather than copying from fixtures dir (which may not have the right phase directory structure), create inline plan files in setup functions. Write helper functions `setup_multi_plan_phase` and `setup_single_plan_phase`:

- `setup_multi_plan_phase`: Creates `.planning/phases/02-test-phase/` with two numbered plan files (02-01-PLAN.md with 2 GSD XML tasks, 02-02-PLAN.md with 1 GSD XML task). Each file has valid frontmatter (phase, plan, type, wave, depends_on, files_modified, autonomous, must_haves) and XML task blocks inside a tasks wrapper.
- `setup_single_plan_phase`: Creates `.planning/phases/03-test-phase/PLAN.md` with 1 GSD XML task (using bare PLAN.md for the single-plan naming convention).

Use heredoc with `'PLAN'` delimiter (single-quoted to prevent shell expansion) to write the fixture files inline via `cat >`. The task XML format is the standard GSD format shown in the research doc and existing plans (task with type attr, name, files, action, verify, done elements).
  </action>
  <verify>
Run `shellcheck -s bash lib/commands/generate.sh` -- no errors.
Run `make check` -- lint + all tests pass.
Run `grep -c '@test' tests/generate.bats` -- at least 15 test cases.
Manually test against real project: `bin/gsd-ralph generate 1` in the gsd-ralph project root (which has .planning/phases/01-project-initialization/ with plan files) -- should generate files into .ralph/generated/.
Verify generated files contain correct content: PROMPT.md has scope lock, fix_plan.md has task checkboxes, .ralphrc has no {{}} placeholders.
Clean up: `rm -rf .ralph/generated` after manual testing.
  </verify>
  <done>
gsd-ralph generate N produces per-plan output directories with PROMPT.md, fix_plan.md, AGENT.md, .ralphrc, and status.json. 15+ integration tests pass in generate.bats covering success, failure, single-plan, multi-plan, and edge cases. The generate command sources discovery.sh and prompt.sh, orchestrating the full generation pipeline. bin/gsd-ralph updated with generate in usage text. make check passes.
  </done>
</task>

</tasks>

<verification>
1. `shellcheck -s bash lib/prompt.sh lib/commands/generate.sh` passes
2. `make check` passes (lint + all tests, including prompt.bats and generate.bats)
3. `grep -c '@test' tests/prompt.bats` >= 10
4. `grep -c '@test' tests/generate.bats` >= 15
5. `bin/gsd-ralph generate 1` produces correct files when run in the project root
6. Generated PROMPT.md contains scope lock, peer visibility (or single-plan note), and project context
7. Generated fix_plan.md contains correct task checkboxes extracted from GSD XML
8. Generated .ralphrc and AGENT.md have no unresolved {{}} placeholders
9. Generated status.json is valid JSON with phase, plan, status fields
10. No bash 4+ features in any new code
</verification>

<success_criteria>
- EXEC-02: Tool generates context-specific PROMPT.md per worktree from templates -- VERIFIED by generate integration tests and PROMPT.md content checks
- EXEC-03: Tool extracts tasks from GSD XML plan format into fix_plan.md -- VERIFIED by prompt.bats task extraction tests and generate.bats fix_plan.md checks
- EXEC-04: Tool generates .ralphrc per worktree with project-specific configuration -- VERIFIED by generate.bats .ralphrc tests and no-placeholder checks
- EXEC-07: Dual naming conventions -- VERIFIED by generate.bats single-plan and multi-plan tests (covered by discovery.sh from Plan 02-01, exercised end-to-end here)
- All tests passing, ShellCheck clean, no bash 4+ features
</success_criteria>

<output>
After completion, create `.planning/phases/02-prompt-generation/02-02-SUMMARY.md`
</output>
