---
phase: 04-merge-orchestration
plan: 03
type: execute
wave: 3
depends_on: [02]
files_modified:
  - lib/merge/signals.sh
  - lib/merge/test_runner.sh
  - lib/commands/merge.sh
  - scripts/ralph-execute.sh
  - tests/merge.bats
autonomous: true
requirements: [MERG-01, MERG-07]

must_haves:
  truths:
    - "After merging all branches for a phase, STATE.md and ROADMAP.md are updated to mark the phase complete"
    - "Wave completion signal file is written to .ralph/merge-signals/ after merging wave branches"
    - "Post-merge test suite runs and only halts on newly-introduced regressions (not pre-existing failures)"
    - "After Ralph completes plan execution, scripts/ralph-execute.sh calls gsd-ralph merge N automatically"
    - "gsd-ralph merge N is a complete end-to-end command: dry-run, merge, auto-resolve, test, signal, state update"
  artifacts:
    - path: "lib/merge/signals.sh"
      provides: "Wave completion signaling and phase completion state updates"
      min_lines: 50
    - path: "lib/merge/test_runner.sh"
      provides: "Post-merge test execution with regression detection"
      min_lines: 40
    - path: "lib/commands/merge.sh"
      provides: "Complete merge command with test, signal, and state update hooks"
      min_lines: 200
    - path: "scripts/ralph-execute.sh"
      provides: "Orchestration wrapper with automatic merge call after Ralph completes"
    - path: "tests/merge.bats"
      provides: "Full test suite for merge command including signals, test runner, and state updates"
      min_lines: 180
  key_links:
    - from: "lib/commands/merge.sh"
      to: "lib/merge/signals.sh"
      via: "source and signal_wave_complete call after merge loop"
      pattern: "signal_wave_complete"
    - from: "lib/commands/merge.sh"
      to: "lib/merge/test_runner.sh"
      via: "source and run_post_merge_tests call after merge loop"
      pattern: "run_post_merge_tests"
    - from: "lib/merge/signals.sh"
      to: ".ralph/merge-signals/"
      via: "file write for wave completion"
      pattern: "merge-signals.*wave.*complete"
    - from: "scripts/ralph-execute.sh"
      to: "gsd-ralph merge"
      via: "CLI invocation of gsd-ralph merge after Ralph exits"
      pattern: "gsd-ralph merge"
---

<objective>
Complete the merge command with post-merge testing (regression-aware), wave completion signaling, STATE.md/ROADMAP.md updates on phase completion, and integrate merge into the execute pipeline so it is called automatically after plan execution.

Purpose: This plan closes the loop -- after merging, the tool verifies no regressions were introduced, signals wave completion for dependency-driven execution, updates project state, and wires merge into the execute flow so the entire execute-merge-next cycle is seamless.
Output: Complete, production-ready `gsd-ralph merge N` command and execute-merge integration.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/04-merge-orchestration/04-01-SUMMARY.md
@.planning/phases/04-merge-orchestration/04-02-SUMMARY.md

# Code being extended
@lib/commands/merge.sh
@scripts/ralph-execute.sh
@lib/common.sh
@lib/config.sh

# Research
@.planning/phases/04-merge-orchestration/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create wave signaling and test runner modules</name>
  <files>lib/merge/signals.sh, lib/merge/test_runner.sh</files>
  <action>
**lib/merge/signals.sh:**
- `SIGNAL_DIR=".ralph/merge-signals"` -- module-level constant
- `signal_wave_complete()` -- takes phase_num, wave_num, and branches_merged (space-separated list). Creates `$SIGNAL_DIR` if needed. Writes JSON signal file to `$SIGNAL_DIR/phase-${phase_num}-wave-${wave_num}-complete` containing: phase, wave, completed_at (ISO timestamp via `date -u +%Y-%m-%dT%H:%M:%SZ`), branches_merged (JSON array built from space-separated input), and main_sha (`git rev-parse HEAD`). Use printf/cat heredoc for JSON construction, not jq, to keep it simple.
- `check_wave_complete()` -- takes phase_num and wave_num. Returns 0 if signal file exists, 1 if not. This is for the execute pipeline to check.
- `update_phase_complete_state()` -- takes phase_num. Updates `.planning/STATE.md`: change Phase line to "Phase: N of 5 -- Complete", Status to "Complete", Last activity to "YYYY-MM-DD -- Phase N merged". Updates `.planning/ROADMAP.md`: change phase status from "Not started" or "In Progress" to "Complete", set Completed column to today's date. Use the sed-based pattern from execute.sh for STATE.md updates. For ROADMAP.md, use sed to update the progress table row for this phase. Commit the state changes: `git add .planning/STATE.md .planning/ROADMAP.md && git commit -m "docs(phase-N): mark phase complete after merge"`.
- `signal_phase_complete()` -- takes phase_num. Calls `update_phase_complete_state "$phase_num"`. Writes a `$SIGNAL_DIR/phase-${phase_num}-complete` signal file with completion metadata.

**lib/merge/test_runner.sh:**
- `run_post_merge_tests()` -- takes test_cmd (string) and pre_merge_sha (string).
  1. If test_cmd is empty, print warning "No test command configured. Skipping post-merge tests." and return 0.
  2. Run test_cmd at current state (post-merge), capture exit code as `post_exit`.
  3. If `post_exit` is 0, print success "All tests passing after merge" and return 0.
  4. If tests fail: compare against pre-merge baseline. Use a simplified approach (per research recommendation):
     - Run tests at pre_merge_sha by: `git stash --include-untracked 2>/dev/null; git checkout "$pre_merge_sha" --detach 2>/dev/null`
     - Capture pre-merge exit code as `pre_exit`
     - Return to post-merge: `git checkout - 2>/dev/null; git stash pop 2>/dev/null || true`
     - If `pre_exit` is also non-zero: print warning "Tests failing, but failures existed before merge. Pre-merge exit: $pre_exit, Post-merge exit: $post_exit." Return 0 (don't halt).
     - If `pre_exit` is 0 but `post_exit` is non-zero: print error "NEW test regressions introduced by merge!" Return 1 (halt -- caller decides whether to rollback).
  5. Handle edge case: if git operations fail during baseline check, print warning and return 0 (don't block merge due to test infrastructure issues).

**Implementation notes:**
- Both files: `#!/bin/bash` header, ShellCheck clean, Bash 3.2 compatible, snake_case functions
- test_runner.sh should not modify the working tree permanently -- always return to the post-merge state even if errors occur (use trap or careful error handling)
- signals.sh JSON construction: build JSON strings with printf, not jq. Convert space-separated list to JSON array: iterate items, build `"item1", "item2"` string, wrap in brackets.
  </action>
  <verify>
`shellcheck lib/merge/signals.sh lib/merge/test_runner.sh` passes.
`bash -n lib/merge/signals.sh && bash -n lib/merge/test_runner.sh` -- syntax check passes.
  </verify>
  <done>
Wave signaling module writes structured JSON signal files to `.ralph/merge-signals/`. Test runner compares pre/post merge test results and only halts on newly-introduced regressions. Phase completion updates STATE.md and ROADMAP.md.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate signals, testing, state updates into merge pipeline and add execute-merge integration</name>
  <files>lib/commands/merge.sh, scripts/ralph-execute.sh, tests/merge.bats</files>
  <action>
**Extend lib/commands/merge.sh:**
- Source the new modules: `$GSD_RALPH_HOME/lib/merge/signals.sh`, `$GSD_RALPH_HOME/lib/merge/test_runner.sh`, `$GSD_RALPH_HOME/lib/config.sh` (for detect_project_type and DETECTED_TEST_CMD)
- After the merge loop (Phase 3 from Plan 04-02) and before the summary output, add:

  **Phase 4 -- Post-merge testing:**
  1. If any branches were successfully merged (MERGE_SUCCESS_COUNT > 0):
     - Call `detect_project_type "."` to get DETECTED_TEST_CMD
     - Get pre_merge_sha from the rollback file: `jq -r '.pre_merge_sha' "$ROLLBACK_FILE"`
     - Call `run_post_merge_tests "$DETECTED_TEST_CMD" "$pre_merge_sha"`
     - If returns 1 (new regressions): print error, suggest `gsd-ralph merge N --rollback` to undo. Set `test_failed=true` for summary.
     - If returns 0: continue

  **Phase 5 -- Wave signaling and state updates:**
  1. Determine current wave: parse frontmatter from plan files to get wave numbers for merged branches. For sequential mode, this is always wave 1. For future parallel mode, group by wave.
  2. Call `signal_wave_complete "$phase_num" "$wave" "$merged_branches_list"`
  3. Check if ALL branches for the phase are merged (no skipped, no remaining): if yes, call `signal_phase_complete "$phase_num"` which updates STATE.md and ROADMAP.md
  4. If not all merged, print info about which branches still need manual resolution

  **Phase 6 -- Summary (already exists from Plan 04-02):**
  - Add test result to summary output: "Tests: passing" or "Tests: REGRESSIONS DETECTED"
  - Add wave signal status: "Wave N complete signal written"

**Wire scripts/ralph-execute.sh to call gsd-ralph merge after Ralph completes:**
This implements the locked decision "Execute always calls merge when a plan completes." The execute CLI command (`gsd-ralph execute`) prepares the environment and exits -- it is NOT synchronous. Ralph runs externally. The orchestration wrapper `scripts/ralph-execute.sh` is where the full execute-Ralph-merge loop lives, so this is the correct place to wire the automatic merge call.

- In `scripts/ralph-execute.sh`, after "Step 5: After All Plans Complete" (which currently just prints instructions), replace the manual merge instructions with an actual automatic merge call:
  1. After Ralph finishes in all worktrees (the script waits for user confirmation that Ralph instances have completed), automatically run:
     ```
     print_step "Step 6: Merge Completed Work"
     print_action "Merging completed branches back to main..."
     cd "$PLANNING_DIR"
     gsd-ralph merge "$PHASE_NUM"
     ```
  2. Keep a `--no-merge` flag on `scripts/ralph-execute.sh` for users who want to skip automatic merge (the "opt-out may come in a later version" note from the locked decision). When `--no-merge` is passed, print the manual merge hint instead of calling merge.
  3. Default behavior (no flag): always call `gsd-ralph merge $PHASE_NUM` after Ralph completes. This satisfies the locked decision.
  4. After merge completes, continue with cleanup suggestion and next-phase suggestion as the script already does.
- The flow becomes: ralph-execute.sh runs gsd-ralph execute -> user starts Ralph -> Ralph finishes -> ralph-execute.sh runs gsd-ralph merge -> cleanup -> next phase.

**Extend tests/merge.bats:**
- "merge runs post-merge tests when test command available" -- set up a project with a test script (create a simple `test.sh` that exits 0), create package.json with test script, merge a branch, assert output contains "All tests passing"
- "merge warns when no test command configured" -- merge in a repo with no detectable test command, assert output contains "No test command configured"
- "merge writes wave completion signal" -- merge a branch, check that `.ralph/merge-signals/phase-N-wave-1-complete` file exists
- "merge updates STATE.md on full phase completion" -- merge all branches for a phase, check STATE.md contains "Complete"
- "merge updates ROADMAP.md on full phase completion" -- merge all branches, check ROADMAP.md progress table shows "Complete" for the phase
- "merge with test regressions suggests rollback" -- create a test script that fails only after merge (exit 1), merge branch, assert output contains "regressions" and "--rollback"
- "ralph-execute.sh calls gsd-ralph merge after completion" -- source or invoke the script in test mode, verify it calls `gsd-ralph merge $PHASE_NUM` after the Ralph completion step (assert output contains "Merging completed branches" and the merge command invocation)
- "ralph-execute.sh --no-merge skips automatic merge" -- invoke with --no-merge flag, verify it prints manual merge hint instead of calling merge automatically
  </action>
  <verify>
`shellcheck lib/commands/merge.sh scripts/ralph-execute.sh lib/merge/signals.sh lib/merge/test_runner.sh` passes.
`bats tests/merge.bats` -- all tests pass (existing + new).
`bats tests/` -- full test suite passes (no regressions).
End-to-end: in a test repo, `gsd-ralph execute N` then `gsd-ralph merge N` completes full cycle. `scripts/ralph-execute.sh` calls merge automatically after Ralph completes.
  </verify>
  <done>
Merge command is complete: dry-run preflight, merge loop, auto-resolve, post-merge testing with regression detection, wave signaling, STATE.md/ROADMAP.md updates, summary output. scripts/ralph-execute.sh automatically calls gsd-ralph merge after Ralph completes (locked decision implemented). Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. Full merge cycle works: execute creates branch, merge merges it back with all safety guarantees
2. Post-merge tests run and correctly distinguish new regressions from pre-existing failures
3. Wave completion signal files are written to `.ralph/merge-signals/`
4. STATE.md and ROADMAP.md are updated when all branches for a phase merge successfully
5. scripts/ralph-execute.sh automatically calls gsd-ralph merge after Ralph completes
6. All tests pass: `bats tests/` (full suite, no regressions)
7. All new code passes ShellCheck
</verification>

<success_criteria>
- `gsd-ralph merge N` is a complete, production-ready command covering all 7 MERG requirements
- Post-merge test regression detection works correctly (pre-existing failures don't block)
- Wave signaling enables future wave-aware execution pipeline
- Phase completion auto-updates project state documents
- Execute-to-merge flow is wired in scripts/ralph-execute.sh (automatic merge after Ralph completes per locked decision)
</success_criteria>

<output>
After completion, create `.planning/phases/04-merge-orchestration/04-03-SUMMARY.md`
</output>
