---
phase: 04-merge-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/merge/dry_run.sh
  - lib/merge/rollback.sh
  - lib/merge/auto_resolve.sh
  - lib/commands/merge.sh
  - tests/merge.bats
autonomous: true
requirements: [MERG-04, MERG-05, MERG-06]

must_haves:
  truths:
    - "merge_dry_run function detects conflicts without touching working tree or index"
    - "save_rollback_point writes pre-merge SHA to .ralph/merge-rollback.json"
    - "rollback_merge resets to saved SHA and removes rollback file"
    - "auto_resolve_known_conflicts resolves .planning/ and lock file conflicts by preferring main"
    - "cmd_merge validates environment, discovers branches for phase, and dispatches to merge pipeline"
  artifacts:
    - path: "lib/merge/dry_run.sh"
      provides: "Dry-run conflict detection using git merge-tree"
      min_lines: 30
    - path: "lib/merge/rollback.sh"
      provides: "Rollback point saving and restoration"
      min_lines: 40
    - path: "lib/merge/auto_resolve.sh"
      provides: "Auto-resolution of known safe file conflicts"
      min_lines: 40
    - path: "lib/commands/merge.sh"
      provides: "Merge command entry point with arg parsing and branch discovery"
      min_lines: 60
    - path: "tests/merge.bats"
      provides: "Integration tests for merge infrastructure"
      min_lines: 50
  key_links:
    - from: "lib/commands/merge.sh"
      to: "lib/merge/dry_run.sh"
      via: "source and function call"
      pattern: "source.*merge/dry_run"
    - from: "lib/commands/merge.sh"
      to: "lib/merge/rollback.sh"
      via: "source and function call"
      pattern: "source.*merge/rollback"
    - from: "lib/commands/merge.sh"
      to: "lib/merge/auto_resolve.sh"
      via: "source and function call"
      pattern: "source.*merge/auto_resolve"
    - from: "lib/commands/merge.sh"
      to: "lib/discovery.sh"
      via: "source for find_phase_dir and discover_plan_files"
      pattern: "source.*discovery"
---

<objective>
Create the merge infrastructure modules (dry-run detection, rollback, auto-resolution) and the merge command skeleton with branch discovery, argument parsing, and environment validation.

Purpose: Establish the foundational building blocks that the merge pipeline (Plan 04-02) will orchestrate. Each module is independently testable and follows the existing lib/ module pattern.
Output: Four library modules (`lib/merge/dry_run.sh`, `lib/merge/rollback.sh`, `lib/merge/auto_resolve.sh`) and the merge command entry point (`lib/commands/merge.sh`) with integration tests.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase outputs needed for patterns
@.planning/phases/03-phase-execution/03-01-SUMMARY.md
@.planning/phases/03-phase-execution/03-02-SUMMARY.md

# Existing code to follow patterns from
@lib/common.sh
@lib/discovery.sh
@lib/config.sh
@lib/commands/execute.sh
@lib/frontmatter.sh
@lib/strategy.sh

# Reference implementation (ad-hoc script being formalized)
@scripts/ralph-merge.sh

# Research informing implementation
@.planning/phases/04-merge-orchestration/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create merge infrastructure modules (dry_run, rollback, auto_resolve)</name>
  <files>lib/merge/dry_run.sh, lib/merge/rollback.sh, lib/merge/auto_resolve.sh</files>
  <action>
Create `lib/merge/` directory and three modules following existing lib/ patterns (functions set globals or return exit codes, ShellCheck clean, Bash 3.2 compatible).

**lib/merge/dry_run.sh:**
- `check_git_merge_tree_support()` -- check Git version >= 2.38 for `git merge-tree --write-tree` support. Parse version from `git --version`, compare major.minor. Return 0 if supported, 1 if not.
- `merge_dry_run()` -- takes branch name, uses `git merge-tree --write-tree --quiet` against current HEAD. Return 0 if clean, 1 if conflicts. IMPORTANT: verify exact exit code semantics -- per docs, exit 0 = clean, exit 1 = conflicts, but test at implementation time. If Git < 2.38, fall back to `git merge --no-commit --no-ff` then `git merge --abort` pattern.
- `merge_dry_run_conflicts()` -- takes branch name, returns list of conflicting file names using `git merge-tree --write-tree --name-only`. Sets global `DRY_RUN_CONFLICTS` (newline-separated list). Falls back to `git diff --name-only --diff-filter=U` in the no-merge-tree path.

**lib/merge/rollback.sh:**
- `ROLLBACK_FILE=".ralph/merge-rollback.json"` -- module-level constant
- `save_rollback_point()` -- takes phase_num, captures `git rev-parse HEAD`, writes JSON to `$ROLLBACK_FILE` with phase, pre_merge_sha, timestamp, and empty branches_merged array. Use `cat` heredoc (not jq) for initial creation to avoid dependency on existing file.
- `record_merged_branch()` -- takes branch name and sha_before, captures sha_after via `git rev-parse HEAD`, appends to branches_merged array in `$ROLLBACK_FILE` using jq.
- `rollback_merge()` -- takes phase_num, reads pre_merge_sha from `$ROLLBACK_FILE`, runs `git reset --hard "$saved_sha"`, removes `$ROLLBACK_FILE`, prints success. Dies if no rollback file exists. Warns that rollback is only possible before pushing.
- `has_rollback_point()` -- returns 0 if `$ROLLBACK_FILE` exists and is valid JSON, 1 otherwise.

**lib/merge/auto_resolve.sh:**
- `AUTO_RESOLVE_PATTERNS` -- array of glob patterns for auto-resolvable files: `.planning/*`, `*.lock`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`, `Cargo.lock`, `.gitignore`. These files are resolved by preferring main's version (--ours during merge on main).
- `matches_auto_resolve_pattern()` -- takes a file path, checks against AUTO_RESOLVE_PATTERNS. Return 0 if matches any pattern, 1 if not. Use case statement with glob matching for Bash 3.2 compatibility (not regex or extglob).
- `auto_resolve_known_conflicts()` -- gets list of conflicted files via `git diff --name-only --diff-filter=U`, iterates each, calls `matches_auto_resolve_pattern`. For matching files: `git checkout --ours -- "$file"` then `git add "$file"`. Tracks resolved vs remaining in globals `AUTO_RESOLVED` and `AUTO_REMAINING` (space-separated). If all resolved, runs `git commit --no-edit` and returns 0. If remaining conflicts exist, returns 1 (merge still incomplete).

All files must have `#!/bin/bash` header and descriptive comment. No associative arrays. No bash 4+ features. Use `local` for function-scoped variables. Follow existing naming patterns (snake_case functions, UPPER_CASE globals).
  </action>
  <verify>
ShellCheck passes on all three files: `shellcheck lib/merge/dry_run.sh lib/merge/rollback.sh lib/merge/auto_resolve.sh`
Files source correctly: `bash -n lib/merge/dry_run.sh && bash -n lib/merge/rollback.sh && bash -n lib/merge/auto_resolve.sh`
  </verify>
  <done>
Three merge infrastructure modules exist with correct function signatures. Each module is independently sourceable. All functions follow Bash 3.2 patterns from existing codebase.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create merge command skeleton with arg parsing, branch discovery, and tests</name>
  <files>lib/commands/merge.sh, tests/merge.bats</files>
  <action>
Replace the existing stub in `lib/commands/merge.sh` with a full command skeleton.

**lib/commands/merge.sh:**
- Source required modules: `$GSD_RALPH_HOME/lib/discovery.sh`, `$GSD_RALPH_HOME/lib/frontmatter.sh`, `$GSD_RALPH_HOME/lib/strategy.sh`, `$GSD_RALPH_HOME/lib/merge/dry_run.sh`, `$GSD_RALPH_HOME/lib/merge/rollback.sh`, `$GSD_RALPH_HOME/lib/merge/auto_resolve.sh`
- `merge_usage()` -- help text showing `gsd-ralph merge [options] <phase_number>` with options: `--rollback` (rollback last merge for this phase), `--review` (show full diffs for each merged branch), `--dry-run` (only show dry-run conflict report, do not merge), `-v, --verbose`, `-h, --help`
- `cmd_merge()` -- main entry point:
  1. Parse arguments: phase_num (required), --rollback, --review, --dry-run, --verbose, --help
  2. Validate environment: git repo (`git rev-parse --is-inside-work-tree`), `.planning/` exists, `.ralph/` exists
  3. Handle --rollback early: if set, call `rollback_merge "$phase_num"` and return
  4. Find phase directory via `find_phase_dir "$phase_num"`
  5. Ensure on main branch: `git symbolic-ref --short HEAD` must be "main" or "master". If not, offer to switch. Store as `$main_branch`.
  6. Verify clean working tree: `git status --porcelain` must be empty. Die with clear message if not.
  7. Discover merge branches via `discover_merge_branches "$phase_num"` (new function, see below)
  8. Print header with phase info
  9. For now, print placeholder "Merge pipeline not yet implemented" (Plan 04-02 builds the actual pipeline)
- `discover_merge_branches()` -- takes phase_num, finds branches belonging to this phase:
  1. Sequential mode: look for `phase-N/slug` branch using the same derivation as execute.sh (`find_phase_dir`, extract slug, build branch name, check `git show-ref --verify --quiet`)
  2. Also check for per-plan branches: `git for-each-ref --format='%(refname:short)' "refs/heads/phase/${phase_num}/"` (future parallel mode)
  3. Filter out branches already merged into main: for each candidate, check `git merge-base --is-ancestor "$branch" HEAD` -- if true, the branch is already merged and should be skipped
  4. Sets global `MERGE_BRANCHES` (array of branch names to merge) and `MERGE_BRANCH_COUNT`
  5. Returns 0 if branches found, 1 if none

**tests/merge.bats:**
Create integration tests following the pattern in `tests/execute.bats`:
- `setup()`: load common, create_test_repo, create_gsd_structure, mkdir .ralph
- `teardown()`: _common_teardown
- Helper `setup_merge_branch()`: creates a phase directory with a plan, creates a branch named `phase-3/phase-execution` with a committed change, switches back to main. This simulates what `gsd-ralph execute` produces.
- Tests:
  - "merge shows usage with --help" -- run with --help, assert output contains "Usage:"
  - "merge requires phase number" -- run without args, assert failure, assert output contains "Phase number required"
  - "merge fails outside git repo" -- run in non-git temp dir, assert failure
  - "merge fails without .planning directory" -- remove .planning, assert failure
  - "merge fails without .ralph directory" -- remove .ralph, assert failure
  - "merge fails with dirty working tree" -- create uncommitted file, assert failure with message about clean working tree
  - "merge discovers sequential branch" -- set up merge branch, run with --dry-run, assert it finds the branch
  - "merge skips already-merged branches" -- create branch, merge it manually, then run merge, assert "No unmerged branches found"
  - "dry_run detects clean merge" -- set up branch with non-conflicting change, source dry_run.sh, call merge_dry_run, assert returns 0
  - "dry_run detects conflicting merge" -- set up branch with conflicting change (same file, same line modified differently), source dry_run.sh, call merge_dry_run, assert returns 1
  - "rollback saves and restores" -- source rollback.sh, save_rollback_point, make a commit, rollback_merge, verify HEAD is at original SHA
  - "auto_resolve resolves .planning/ conflicts" -- create merge conflict in .planning/STATE.md, source auto_resolve.sh, call auto_resolve_known_conflicts, verify conflict resolved

Tests should use the same helpers from `tests/test_helper/common.bash`.
  </action>
  <verify>
`shellcheck lib/commands/merge.sh` passes.
`bats tests/merge.bats` -- all tests pass.
`gsd-ralph merge --help` prints usage text.
`gsd-ralph merge` (no args) exits with error about missing phase number.
  </verify>
  <done>
Merge command skeleton handles argument parsing, environment validation, branch discovery, --rollback dispatch, and --dry-run mode. 12+ integration tests pass covering infrastructure modules and command scaffolding. The merge pipeline placeholder is ready for Plan 04-02 to fill in.
  </done>
</task>

</tasks>

<verification>
1. All new files pass ShellCheck: `shellcheck lib/merge/*.sh lib/commands/merge.sh`
2. All tests pass: `bats tests/merge.bats`
3. No regressions: `bats tests/` (all existing tests still pass)
4. `gsd-ralph merge --help` displays correct usage
5. `gsd-ralph merge 3 --dry-run` discovers branches and shows dry-run report (in a test repo with a phase-3 branch)
6. `gsd-ralph merge 3 --rollback` works when a rollback point exists
</verification>

<success_criteria>
- Merge infrastructure modules (dry_run, rollback, auto_resolve) exist and are testable in isolation
- Merge command validates environment, discovers branches, handles --rollback and --dry-run
- All existing tests continue to pass (no regressions)
- Branch discovery correctly identifies phase branches and filters already-merged ones
</success_criteria>

<output>
After completion, create `.planning/phases/04-merge-orchestration/04-01-SUMMARY.md`
</output>
