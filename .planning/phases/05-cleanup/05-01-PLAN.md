---
phase: 05-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/cleanup/registry.sh
  - lib/commands/execute.sh
autonomous: true
requirements:
  - CLEN-02

must_haves:
  truths:
    - "Worktree registry file is created at .ralph/worktree-registry.json when first worktree is registered"
    - "Registry records worktree path, branch name, and timestamp for each registration"
    - "Execute command registers the branch it creates in the registry automatically"
    - "Registry entries are keyed by phase number, supporting multiple entries per phase"
  artifacts:
    - path: "lib/cleanup/registry.sh"
      provides: "Worktree registry init, register, list, deregister functions"
      exports: ["init_registry", "register_worktree", "list_registered_worktrees", "deregister_phase", "validate_registry"]
    - path: ".ralph/worktree-registry.json"
      provides: "Persistent worktree tracking keyed by phase number"
      contains: "version"
  key_links:
    - from: "lib/commands/execute.sh"
      to: "lib/cleanup/registry.sh"
      via: "source and register_worktree() call after branch creation"
      pattern: "register_worktree.*phase_num"
    - from: "lib/cleanup/registry.sh"
      to: ".ralph/worktree-registry.json"
      via: "jq read/write operations"
      pattern: "jq.*WORKTREE_REGISTRY"
---

<objective>
Create the worktree registry module and wire it into the execute command so that every branch created by `gsd-ralph execute` is tracked in a JSON registry file.

Purpose: The registry is the foundation for CLEN-02 (registry-driven cleanup). Without it, cleanup would have to rely on glob-based discovery, which risks deleting unrelated worktrees. The execute integration ensures the registry is populated from the moment branches are created.

Output: `lib/cleanup/registry.sh` module with init/register/list/deregister/validate functions, and a 3-line integration into `lib/commands/execute.sh`.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/commands/execute.sh
@lib/common.sh
@lib/merge/rollback.sh
@.planning/phases/05-cleanup/05-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worktree registry module</name>
  <files>lib/cleanup/registry.sh</files>
  <action>
Create `lib/cleanup/registry.sh` with these functions:

**WORKTREE_REGISTRY** global: `".ralph/worktree-registry.json"`

**init_registry()**: Create the registry file with `{"version": 1}` if it does not exist. If it already exists, validate it is parseable JSON (jq -e . >/dev/null 2>&1). If invalid JSON, print a warning via `print_warning` and recreate with `{"version": 1}`.

**register_worktree(phase_num, worktree_path, branch_name)**: Call `init_registry` first. Use jq to add an entry `{"worktree_path": $wt, "branch": $br, "created_at": $ts}` to the array at key `$phase_num`. If the phase key does not exist, create it as a new array. Use `date -u +%Y-%m-%dT%H:%M:%SZ` for timestamp (portable, already used throughout codebase). Write to a temp variable first, then write to file (same pattern as `lib/merge/rollback.sh` line 51-54).

**list_registered_worktrees(phase_num)**: If registry file does not exist, echo `[]` and return. Otherwise use `jq --arg phase "$phase_num" '.[$phase] // []'` to output the entries.

**deregister_phase(phase_num)**: If registry file does not exist, return 0. Otherwise use `jq --arg phase "$phase_num" 'del(.[$phase])'` to remove the phase key.

**validate_registry()**: Return 0 if the registry file exists and is valid JSON. Return 1 otherwise. Use `jq -e . "$WORKTREE_REGISTRY" >/dev/null 2>&1`.

Follow existing module patterns:
- Shebang `#!/bin/bash` with comment header matching `lib/merge/rollback.sh` style
- Use `print_verbose` for debug-level messages
- No `set -e` (sourced module, not standalone)
- All functions use `local` for variables
  </action>
  <verify>
Source the file in a bash shell and confirm all 5 functions are defined:
```bash
source lib/common.sh && source lib/cleanup/registry.sh && type init_registry register_worktree list_registered_worktrees deregister_phase validate_registry
```
Verify register_worktree creates a valid JSON file:
```bash
mkdir -p .ralph && init_registry && register_worktree "5" "/tmp/test" "phase-5/test" && jq . .ralph/worktree-registry.json
```
  </verify>
  <done>
lib/cleanup/registry.sh exists with 5 exported functions. init_registry creates a version-1 JSON file. register_worktree adds entries keyed by phase number. list_registered_worktrees returns phase entries or empty array. deregister_phase removes a phase key. validate_registry checks JSON validity.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire registry into execute command</name>
  <files>lib/commands/execute.sh</files>
  <action>
Modify `lib/commands/execute.sh` to register the branch it creates:

1. Add a source line at the top with the other source statements (after line 13, the `source strategy.sh` line):
```bash
# shellcheck source=/dev/null
source "$GSD_RALPH_HOME/lib/cleanup/registry.sh"
```

2. After the branch is created (after line 155, `print_success "Created branch: $branch_name"`), add the registration call:
```bash
register_worktree "$phase_num" "$(pwd)" "$branch_name"
print_verbose "Registered branch in worktree registry"
```

This is a minimal 3-line change. The execute command already creates the `.ralph/` directory (line 158: `mkdir -p .ralph/logs`), so the registry module's `init_registry()` can safely write to `.ralph/worktree-registry.json`.

Do NOT modify any other logic in execute.sh. The registration is fire-and-forget -- it should not affect execute's control flow or exit codes.
  </action>
  <verify>
Run `gsd-ralph execute --dry-run` to confirm the execute command still loads without errors (dry-run exits before branch creation, so no registry write occurs, but sourcing is validated).

Run the existing execute tests to confirm no regressions:
```bash
./tests/bats/bin/bats tests/execute.bats
```
  </verify>
  <done>
execute.sh sources lib/cleanup/registry.sh and calls register_worktree after branch creation. All existing execute tests pass without modification.
  </done>
</task>

</tasks>

<verification>
1. `source lib/common.sh && source lib/cleanup/registry.sh` succeeds without errors
2. Registry functions create valid JSON at `.ralph/worktree-registry.json`
3. `register_worktree "5" "/tmp/test" "phase-5/test"` produces JSON with version field and phase-5 entry
4. `list_registered_worktrees "5"` returns the registered entry
5. `deregister_phase "5"` removes the entry
6. `./tests/bats/bin/bats tests/execute.bats` passes (no regressions)
</verification>

<success_criteria>
- lib/cleanup/registry.sh exists with init_registry, register_worktree, list_registered_worktrees, deregister_phase, validate_registry
- Registry JSON file uses version field for future-proofing
- execute.sh registers branches at creation time without affecting existing behavior
- All existing execute tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-cleanup/05-01-SUMMARY.md`
</output>
