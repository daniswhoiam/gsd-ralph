---
phase: 04-merge-orchestration
plan: 03
type: execute
wave: 3
depends_on: [02]
files_modified:
  - lib/merge/signals.sh
  - lib/merge/test_runner.sh
  - lib/commands/merge.sh
  - lib/commands/execute.sh
  - tests/merge.bats
autonomous: true
requirements: [MERG-01, MERG-07]

must_haves:
  truths:
    - "After merging all branches for a phase, STATE.md and ROADMAP.md are updated to mark the phase complete"
    - "Wave completion signal file is written to .ralph/merge-signals/ after merging wave branches"
    - "Post-merge test suite runs and only halts on newly-introduced regressions (not pre-existing failures)"
    - "Execute command calls merge automatically after Ralph completes plan execution"
    - "gsd-ralph merge N is a complete end-to-end command: dry-run, merge, auto-resolve, test, signal, state update"
  artifacts:
    - path: "lib/merge/signals.sh"
      provides: "Wave completion signaling and phase completion state updates"
      min_lines: 50
    - path: "lib/merge/test_runner.sh"
      provides: "Post-merge test execution with regression detection"
      min_lines: 40
    - path: "lib/commands/merge.sh"
      provides: "Complete merge command with test, signal, and state update hooks"
      min_lines: 200
    - path: "lib/commands/execute.sh"
      provides: "Execute command with merge integration"
    - path: "tests/merge.bats"
      provides: "Full test suite for merge command including signals, test runner, and state updates"
      min_lines: 180
  key_links:
    - from: "lib/commands/merge.sh"
      to: "lib/merge/signals.sh"
      via: "source and signal_wave_complete call after merge loop"
      pattern: "signal_wave_complete"
    - from: "lib/commands/merge.sh"
      to: "lib/merge/test_runner.sh"
      via: "source and run_post_merge_tests call after merge loop"
      pattern: "run_post_merge_tests"
    - from: "lib/merge/signals.sh"
      to: ".ralph/merge-signals/"
      via: "file write for wave completion"
      pattern: "merge-signals.*wave.*complete"
    - from: "lib/commands/execute.sh"
      to: "lib/commands/merge.sh"
      via: "source and cmd_merge call after execution"
      pattern: "cmd_merge\\|source.*merge"
---

<objective>
Complete the merge command with post-merge testing (regression-aware), wave completion signaling, STATE.md/ROADMAP.md updates on phase completion, and integrate merge into the execute pipeline so it is called automatically after plan execution.

Purpose: This plan closes the loop -- after merging, the tool verifies no regressions were introduced, signals wave completion for dependency-driven execution, updates project state, and wires merge into the execute flow so the entire execute-merge-next cycle is seamless.
Output: Complete, production-ready `gsd-ralph merge N` command and execute-merge integration.
</objective>

<execution_context>
@/Users/daniswhoiam/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniswhoiam/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/04-merge-orchestration/04-01-SUMMARY.md
@.planning/phases/04-merge-orchestration/04-02-SUMMARY.md

# Code being extended
@lib/commands/merge.sh
@lib/commands/execute.sh
@lib/common.sh
@lib/config.sh

# Research
@.planning/phases/04-merge-orchestration/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create wave signaling and test runner modules</name>
  <files>lib/merge/signals.sh, lib/merge/test_runner.sh</files>
  <action>
**lib/merge/signals.sh:**
- `SIGNAL_DIR=".ralph/merge-signals"` -- module-level constant
- `signal_wave_complete()` -- takes phase_num, wave_num, and branches_merged (space-separated list). Creates `$SIGNAL_DIR` if needed. Writes JSON signal file to `$SIGNAL_DIR/phase-${phase_num}-wave-${wave_num}-complete` containing: phase, wave, completed_at (ISO timestamp via `date -u +%Y-%m-%dT%H:%M:%SZ`), branches_merged (JSON array built from space-separated input), and main_sha (`git rev-parse HEAD`). Use printf/cat heredoc for JSON construction, not jq, to keep it simple.
- `check_wave_complete()` -- takes phase_num and wave_num. Returns 0 if signal file exists, 1 if not. This is for the execute pipeline to check.
- `update_phase_complete_state()` -- takes phase_num. Updates `.planning/STATE.md`: change Phase line to "Phase: N of 5 -- Complete", Status to "Complete", Last activity to "YYYY-MM-DD -- Phase N merged". Updates `.planning/ROADMAP.md`: change phase status from "Not started" or "In Progress" to "Complete", set Completed column to today's date. Use the sed-based pattern from execute.sh for STATE.md updates. For ROADMAP.md, use sed to update the progress table row for this phase. Commit the state changes: `git add .planning/STATE.md .planning/ROADMAP.md && git commit -m "docs(phase-N): mark phase complete after merge"`.
- `signal_phase_complete()` -- takes phase_num. Calls `update_phase_complete_state "$phase_num"`. Writes a `$SIGNAL_DIR/phase-${phase_num}-complete` signal file with completion metadata.

**lib/merge/test_runner.sh:**
- `run_post_merge_tests()` -- takes test_cmd (string) and pre_merge_sha (string).
  1. If test_cmd is empty, print warning "No test command configured. Skipping post-merge tests." and return 0.
  2. Run test_cmd at current state (post-merge), capture exit code as `post_exit`.
  3. If `post_exit` is 0, print success "All tests passing after merge" and return 0.
  4. If tests fail: compare against pre-merge baseline. Use a simplified approach (per research recommendation):
     - Run tests at pre_merge_sha by: `git stash --include-untracked 2>/dev/null; git checkout "$pre_merge_sha" --detach 2>/dev/null`
     - Capture pre-merge exit code as `pre_exit`
     - Return to post-merge: `git checkout - 2>/dev/null; git stash pop 2>/dev/null || true`
     - If `pre_exit` is also non-zero: print warning "Tests failing, but failures existed before merge. Pre-merge exit: $pre_exit, Post-merge exit: $post_exit." Return 0 (don't halt).
     - If `pre_exit` is 0 but `post_exit` is non-zero: print error "NEW test regressions introduced by merge!" Return 1 (halt -- caller decides whether to rollback).
  5. Handle edge case: if git operations fail during baseline check, print warning and return 0 (don't block merge due to test infrastructure issues).

**Implementation notes:**
- Both files: `#!/bin/bash` header, ShellCheck clean, Bash 3.2 compatible, snake_case functions
- test_runner.sh should not modify the working tree permanently -- always return to the post-merge state even if errors occur (use trap or careful error handling)
- signals.sh JSON construction: build JSON strings with printf, not jq. Convert space-separated list to JSON array: iterate items, build `"item1", "item2"` string, wrap in brackets.
  </action>
  <verify>
`shellcheck lib/merge/signals.sh lib/merge/test_runner.sh` passes.
`bash -n lib/merge/signals.sh && bash -n lib/merge/test_runner.sh` -- syntax check passes.
  </verify>
  <done>
Wave signaling module writes structured JSON signal files to `.ralph/merge-signals/`. Test runner compares pre/post merge test results and only halts on newly-introduced regressions. Phase completion updates STATE.md and ROADMAP.md.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate signals, testing, state updates into merge pipeline and add execute-merge integration</name>
  <files>lib/commands/merge.sh, lib/commands/execute.sh, tests/merge.bats</files>
  <action>
**Extend lib/commands/merge.sh:**
- Source the new modules: `$GSD_RALPH_HOME/lib/merge/signals.sh`, `$GSD_RALPH_HOME/lib/merge/test_runner.sh`, `$GSD_RALPH_HOME/lib/config.sh` (for detect_project_type and DETECTED_TEST_CMD)
- After the merge loop (Phase 3 from Plan 04-02) and before the summary output, add:

  **Phase 4 -- Post-merge testing:**
  1. If any branches were successfully merged (MERGE_SUCCESS_COUNT > 0):
     - Call `detect_project_type "."` to get DETECTED_TEST_CMD
     - Get pre_merge_sha from the rollback file: `jq -r '.pre_merge_sha' "$ROLLBACK_FILE"`
     - Call `run_post_merge_tests "$DETECTED_TEST_CMD" "$pre_merge_sha"`
     - If returns 1 (new regressions): print error, suggest `gsd-ralph merge N --rollback` to undo. Set `test_failed=true` for summary.
     - If returns 0: continue

  **Phase 5 -- Wave signaling and state updates:**
  1. Determine current wave: parse frontmatter from plan files to get wave numbers for merged branches. For sequential mode, this is always wave 1. For future parallel mode, group by wave.
  2. Call `signal_wave_complete "$phase_num" "$wave" "$merged_branches_list"`
  3. Check if ALL branches for the phase are merged (no skipped, no remaining): if yes, call `signal_phase_complete "$phase_num"` which updates STATE.md and ROADMAP.md
  4. If not all merged, print info about which branches still need manual resolution

  **Phase 6 -- Summary (already exists from Plan 04-02):**
  - Add test result to summary output: "Tests: passing" or "Tests: REGRESSIONS DETECTED"
  - Add wave signal status: "Wave N complete signal written"

**Extend lib/commands/execute.sh:**
- After Step 13 (print launch instructions), add a new comment block:
  ```
  # Step 14: Post-execution merge hint
  # Note: In the execute-merge loop, Ralph runs on the branch and upon
  # completion, the orchestrator calls gsd-ralph merge to merge back.
  # This hint tells the user the expected next step after Ralph finishes.
  ```
- Add to the launch instructions output:
  ```
  print_info "After Ralph completes, merge back to main:"
  print_info "  gsd-ralph merge $phase_num"
  ```
- Do NOT auto-call merge from execute -- execute sets up the environment, Ralph runs (outside gsd-ralph), then the user or orchestrating script calls merge. The "execute always calls merge" locked decision refers to the Ralph execution loop (the wrapper script), not the execute command itself. The execute command's job is to prepare the environment. The merge call happens after Ralph completes, either manually or via the ralph-execute wrapper script.
- Update `scripts/ralph-execute.sh` (if it exists and is relevant) or add a comment in execute.sh documenting the intended flow: execute -> Ralph runs -> merge.

**Extend tests/merge.bats:**
- "merge runs post-merge tests when test command available" -- set up a project with a test script (create a simple `test.sh` that exits 0), create package.json with test script, merge a branch, assert output contains "All tests passing"
- "merge warns when no test command configured" -- merge in a repo with no detectable test command, assert output contains "No test command configured"
- "merge writes wave completion signal" -- merge a branch, check that `.ralph/merge-signals/phase-N-wave-1-complete` file exists
- "merge updates STATE.md on full phase completion" -- merge all branches for a phase, check STATE.md contains "Complete"
- "merge updates ROADMAP.md on full phase completion" -- merge all branches, check ROADMAP.md progress table shows "Complete" for the phase
- "merge with test regressions suggests rollback" -- create a test script that fails only after merge (exit 1), merge branch, assert output contains "regressions" and "--rollback"
- "execute shows merge hint in output" -- run execute, assert output contains "gsd-ralph merge"
  </action>
  <verify>
`shellcheck lib/commands/merge.sh lib/commands/execute.sh lib/merge/signals.sh lib/merge/test_runner.sh` passes.
`bats tests/merge.bats` -- all tests pass (existing + new).
`bats tests/execute.bats` -- existing execute tests still pass.
`bats tests/` -- full test suite passes (no regressions).
End-to-end: in a test repo, `gsd-ralph execute N` then `gsd-ralph merge N` completes full cycle.
  </verify>
  <done>
Merge command is complete: dry-run preflight, merge loop, auto-resolve, post-merge testing with regression detection, wave signaling, STATE.md/ROADMAP.md updates, summary output. Execute command includes merge hint. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. Full merge cycle works: execute creates branch, merge merges it back with all safety guarantees
2. Post-merge tests run and correctly distinguish new regressions from pre-existing failures
3. Wave completion signal files are written to `.ralph/merge-signals/`
4. STATE.md and ROADMAP.md are updated when all branches for a phase merge successfully
5. Execute command output includes merge hint
6. All tests pass: `bats tests/` (full suite, no regressions)
7. All new code passes ShellCheck
</verification>

<success_criteria>
- `gsd-ralph merge N` is a complete, production-ready command covering all 7 MERG requirements
- Post-merge test regression detection works correctly (pre-existing failures don't block)
- Wave signaling enables future wave-aware execution pipeline
- Phase completion auto-updates project state documents
- Execute-to-merge flow is documented and hinted to the user
</success_criteria>

<output>
After completion, create `.planning/phases/04-merge-orchestration/04-03-SUMMARY.md`
</output>
